// Autogenerated by Thrift Compiler (0.11.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

pub type Temperature = i64;

pub type Size = i8;

pub type Location = String;

//
// Noodle
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Noodle {
  pub flour_type: Option<String>,
  pub cook_temp: Option<Temperature>,
}

impl Noodle {
  pub fn new<F1, F2>(flour_type: F1, cook_temp: F2) -> Noodle where F1: Into<Option<String>>, F2: Into<Option<Temperature>> {
    Noodle {
      flour_type: flour_type.into(),
      cook_temp: cook_temp.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Noodle> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Temperature> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Noodle {
      flour_type: f_1,
      cook_temp: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Noodle");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.flour_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("flourType", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cook_temp {
      o_prot.write_field_begin(&TFieldIdentifier::new("cookTemp", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Noodle {
  fn default() -> Self {
    Noodle{
      flour_type: Some("".to_owned()),
      cook_temp: Some(0),
    }
  }
}

//
// Spaghetti
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Spaghetti {
  pub noodles: Option<Vec<Noodle>>,
}

impl Spaghetti {
  pub fn new<F1>(noodles: F1) -> Spaghetti where F1: Into<Option<Vec<Noodle>>> {
    Spaghetti {
      noodles: noodles.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Spaghetti> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Noodle>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Noodle> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = Noodle::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Spaghetti {
      noodles: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Spaghetti");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.noodles {
      o_prot.write_field_begin(&TFieldIdentifier::new("noodles", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Spaghetti {
  fn default() -> Self {
    Spaghetti{
      noodles: Some(Vec::new()),
    }
  }
}

//
// MeasuringSpoon
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MeasuringSpoon {
  pub size: Option<Size>,
}

impl MeasuringSpoon {
  pub fn new<F1>(size: F1) -> MeasuringSpoon where F1: Into<Option<Size>> {
    MeasuringSpoon {
      size: size.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<MeasuringSpoon> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Size> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MeasuringSpoon {
      size: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MeasuringSpoon");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.size {
      o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I08, 1))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for MeasuringSpoon {
  fn default() -> Self {
    MeasuringSpoon{
      size: Some(0),
    }
  }
}

//
// MeasuringCup
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MeasuringCup {
  pub millis: Option<OrderedFloat<f64>>,
}

impl MeasuringCup {
  pub fn new<F1>(millis: F1) -> MeasuringCup where F1: Into<Option<OrderedFloat<f64>>> {
    MeasuringCup {
      millis: millis.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<MeasuringCup> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MeasuringCup {
      millis: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MeasuringCup");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.millis {
      o_prot.write_field_begin(&TFieldIdentifier::new("millis", TType::Double, 1))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for MeasuringCup {
  fn default() -> Self {
    MeasuringCup{
      millis: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// MeasuringAids
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum MeasuringAids {
  Spoon(MeasuringSpoon),
  Cup(MeasuringCup),
}

impl MeasuringAids {
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<MeasuringAids> {
    let mut ret: Option<MeasuringAids> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = MeasuringSpoon::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(MeasuringAids::Spoon(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = MeasuringCup::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(MeasuringAids::Cup(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote MeasuringAids"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote MeasuringAids"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MeasuringAids");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      MeasuringAids::Spoon(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("spoon", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      MeasuringAids::Cup(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("cup", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CookingTemperatures
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CookingTemperatures {
  pub common_temperatures: Option<BTreeSet<OrderedFloat<f64>>>,
  pub used_temperatures: Option<Vec<OrderedFloat<f64>>>,
  pub fahrenheit_to_centigrade_conversions: Option<BTreeMap<OrderedFloat<f64>, OrderedFloat<f64>>>,
}

impl CookingTemperatures {
  pub fn new<F1, F2, F3>(common_temperatures: F1, used_temperatures: F2, fahrenheit_to_centigrade_conversions: F3) -> CookingTemperatures where F1: Into<Option<BTreeSet<OrderedFloat<f64>>>>, F2: Into<Option<Vec<OrderedFloat<f64>>>>, F3: Into<Option<BTreeMap<OrderedFloat<f64>, OrderedFloat<f64>>>> {
    CookingTemperatures {
      common_temperatures: common_temperatures.into(),
      used_temperatures: used_temperatures.into(),
      fahrenheit_to_centigrade_conversions: fahrenheit_to_centigrade_conversions.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<CookingTemperatures> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeSet<OrderedFloat<f64>>> = Some(BTreeSet::new());
    let mut f_2: Option<Vec<OrderedFloat<f64>>> = Some(Vec::new());
    let mut f_3: Option<BTreeMap<OrderedFloat<f64>, OrderedFloat<f64>>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<OrderedFloat<f64>> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_1 = OrderedFloat::from(i_prot.read_double()?);
            val.insert(set_elem_1);
          }
          i_prot.read_set_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<OrderedFloat<f64>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = OrderedFloat::from(i_prot.read_double()?);
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<OrderedFloat<f64>, OrderedFloat<f64>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_3 = OrderedFloat::from(i_prot.read_double()?);
            let map_val_4 = OrderedFloat::from(i_prot.read_double()?);
            val.insert(map_key_3, map_val_4);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CookingTemperatures {
      common_temperatures: f_1,
      used_temperatures: f_2,
      fahrenheit_to_centigrade_conversions: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CookingTemperatures");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.common_temperatures {
      o_prot.write_field_begin(&TFieldIdentifier::new("commonTemperatures", TType::Set, 1))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::Double, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_double((*e).into())?;
        o_prot.write_set_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.used_temperatures {
      o_prot.write_field_begin(&TFieldIdentifier::new("usedTemperatures", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Double, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_double((*e).into())?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.fahrenheit_to_centigrade_conversions {
      o_prot.write_field_begin(&TFieldIdentifier::new("fahrenheitToCentigradeConversions", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::Double, TType::Double, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_double((*k).into())?;
        o_prot.write_double((*v).into())?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CookingTemperatures {
  fn default() -> Self {
    CookingTemperatures{
      common_temperatures: Some(BTreeSet::new()),
      used_temperatures: Some(Vec::new()),
      fahrenheit_to_centigrade_conversions: Some(BTreeMap::new()),
    }
  }
}

//
// Recipe
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Recipe {
  pub recipe_name: Option<String>,
  pub cuisine: Option<String>,
  pub page: Option<i8>,
}

impl Recipe {
  pub fn new<F1, F2, F3>(recipe_name: F1, cuisine: F2, page: F3) -> Recipe where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i8>> {
    Recipe {
      recipe_name: recipe_name.into(),
      cuisine: cuisine.into(),
      page: page.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Recipe> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i8> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i8()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Recipe {
      recipe_name: f_1,
      cuisine: f_2,
      page: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Recipe");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.recipe_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipeName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.cuisine {
      o_prot.write_field_begin(&TFieldIdentifier::new("cuisine", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.page {
      o_prot.write_field_begin(&TFieldIdentifier::new("page", TType::I08, 3))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Recipe {
  fn default() -> Self {
    Recipe{
      recipe_name: Some("".to_owned()),
      cuisine: Some("".to_owned()),
      page: Some(0),
    }
  }
}

//
// CookingTools
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum CookingTools {
  MeasuringSpoons(BTreeSet<MeasuringSpoon>),
  MeasuringCups(BTreeMap<Size, Location>),
  Recipes(Vec<Recipe>),
}

impl CookingTools {
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<CookingTools> {
    let mut ret: Option<CookingTools> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<MeasuringSpoon> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_5 = MeasuringSpoon::read_from_in_protocol(i_prot)?;
            val.insert(set_elem_5);
          }
          i_prot.read_set_end()?;
          if ret.is_none() {
            ret = Some(CookingTools::MeasuringSpoons(val));
          }
          received_field_count += 1;
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<Size, Location> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_6 = i_prot.read_i8()?;
            let map_val_7 = i_prot.read_string()?;
            val.insert(map_key_6, map_val_7);
          }
          i_prot.read_map_end()?;
          if ret.is_none() {
            ret = Some(CookingTools::MeasuringCups(val));
          }
          received_field_count += 1;
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Recipe> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = Recipe::read_from_in_protocol(i_prot)?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          if ret.is_none() {
            ret = Some(CookingTools::Recipes(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote CookingTools"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote CookingTools"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CookingTools");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      CookingTools::MeasuringSpoons(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("measuringSpoons", TType::Set, 1))?;
        o_prot.write_set_begin(&TSetIdentifier::new(TType::Struct, f.len() as i32))?;
        for e in f {
          e.write_to_out_protocol(o_prot)?;
          o_prot.write_set_end()?;
        }
        o_prot.write_field_end()?;
      },
      CookingTools::MeasuringCups(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("measuringCups", TType::Map, 2))?;
        o_prot.write_map_begin(&TMapIdentifier::new(TType::I08, TType::String, f.len() as i32))?;
        for (k, v) in f {
          o_prot.write_i8(*k)?;
          o_prot.write_string(v)?;
          o_prot.write_map_end()?;
        }
        o_prot.write_field_end()?;
      },
      CookingTools::Recipes(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("recipes", TType::List, 3))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, f.len() as i32))?;
        for e in f {
          e.write_to_out_protocol(o_prot)?;
          o_prot.write_list_end()?;
        }
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

pub const BOILING_POINT: i32 = 100;

pub struct ConstTemperatures;
impl ConstTemperatures {
  pub fn const_value() -> Vec<Temperature> {
    {
      let mut l: Vec<Temperature> = Vec::new();
      l.push(10);
      l.push(11);
      l.push(22);
      l.push(33);
      l
    }
  }
}

pub struct ConstCommonTemperatures;
impl ConstCommonTemperatures {
  pub fn const_value() -> Vec<OrderedFloat<f64>> {
    {
      let mut l: Vec<OrderedFloat<f64>> = Vec::new();
      l.push(OrderedFloat::from(300 as f64));
      l.push(OrderedFloat::from(450 as f64));
      l
    }
  }
}

pub struct ConstMealsPerDay;
impl ConstMealsPerDay {
  pub fn const_value() -> OrderedFloat<f64> {
OrderedFloat::from(2.5 as f64)  }
}

pub struct ConstSpeltNoodle;
impl ConstSpeltNoodle {
  pub fn const_value() -> Noodle {
    {
      unimplemented!()
    }
  }
}

